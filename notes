;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

todo
-----------

- balance report
 - include transfers
  - at end loop through transfers and increase and decrease as needed
   - both base_balance and balance

- ledgers is just that, no need to adjust for account transfers
- use transfers from bank to cash to cover owner use of cash


- fx
 - calc value give date, src_cur, dest_cur, src_amount

- store amounts as integers
 - currency should identify shift
 - currency should specify format (maybe a function to return amount as string)

- transfers
 - bw to usd
 - bw to cad (with fx loss)
 - look for all transfers in 2017

- put formatting in currency
 - include symbol like $
 - so maybe a val_s or something

- ledger entries
 - load ledger entries one year at a time
 - spreadsheet
  - make sure all categories map
  + import (backup first!)
  - balance report
   - ledger, each account
  - link report
  - link
   - for each transaction look for matching in one of accounts (with correct currency)
   - ask to link for each (later -y for auto yes)
  - receipt report
  - associate receipt

- cach account (owner) resolve to get target
 - $16,494.72 ?
 - $15,554.88 USD 21,575 CAD outstanding invoice
 - $3988.43 USD 2925.00 CAD withheld
 - total -3048.59
 - conversion may be slightly different

- import command
 - ledger from csv file

- dup check for ledger
- match check
 - match account, amount, and date withing X days
 - verbose shows matches

- trans should include tip (not taxed)

- do all cmds
 - show for all
 - list
 - create
 - update
 - delete

- update account
 - cmd
  - file=
  - id=
  - use same approach as inputs
  - Cmd::Base < Input::Base
  - should input just be cmd? probably

- account


also various taxes for FTB and IRS

- implement all models in schema along with validation
 + Fx
 + Currency
 + Rate
 + Customer
 + Contact
 + Invoice
 + Payment
 + Category
 + Tax
 + TaxAmount
 + Account
 + BankTrans
 + Transaction
 + Company
 - Query
 - Mutation

- Report (for graphql and for csv)


- input
 - customer
 - account
 - category
 - person
 - payment
 - bank (info into conf)
 - tax
 - transaction


- input classes
 - validate values and lookup as needed
 - check for duplicates
 - create account next

- add classes for each schema type
- decide on command handling
 - verb type options/args
 - separate cmd module
  - handle parsing and switching in cmd
   - Cmd.run(verb, type, args={})

- add input for each and start adding
 - allow command line args to set fields


- crud + list
 - by object - invoice new ...
 - or by op - new invoice ...
  - more consistent with report xxx

 - allow values to be provide like id=INV-20191111
  - if provided they are not prompted for
 - perform consitency checks
  - referenced object exist like accounts, customer, ect

- reports - generic or *specific*
 - specific
  - easy to get ID for operations on row object
  - can implement things like filtering row for display based on hidden attributes
  - can display items differently, boolean as checkbox for example or images for status
 - generic
  - use same display code
  - need position indicator for ID
  - need alignment indicator for each column
   - basically need to pass more info about the table
 - really come down to how to think about reports, are they generic or each custom

 - list
  - late
  - invoices
  - payments
  - accounts
  - customers
  - rates
  - vendors
  - P&L
  - transactions - mixed currencies
   - all
   - by account
  - balance sheet by category
  - income
   - minus expenses by category
   - by customer
   - outstanding (invoices not yet paid)
  - expense
   - by category
   - by vendor
  - general ledger
   - by category
   - all normalized to currency
  - sales tax
  - currency exchange gain and loss

- if generic
type Row {
  cells: [Cell]
}

type Cell {
  key: String # optional?
  int: Int
  str: String
  date: Date
  float: Float
  currency: Float
  bool: Boolean
}


- from web, use invoice, accounts, etc for reports with some special cases for some reports
- for console / terminal make special report for each
- graphql to trigger csv generation - provide header, object, and fields in orde

type Company {
  " Returns filepath to download. "
  classReport(class: String!, filter: Filter, header: [String], columns: [String]): String
}

Invoice {
  report(filter: Fliter, columns: [Kv]) String
}

type Kv {
  key: String
  val: String # column header if an arg to report
}

report(columns: [ {key: "one", val: "First"}, ...])
