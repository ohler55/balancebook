;; -*- mode: outline; outline-regexp: " *[-\+]"; indent-tabs-mode: nil; fill-column: 120 -*-

todo
-----------

- input classes
 - validate values and lookup as needed
 - check for duplicates

- add classes for each schema type
- decide on command handling
 - verb type options/args
 - separate cmd module
  - handle parsing and switching in cmd
   - Cmd.run(verb, type, args={})

- add input for each and start adding
 - allow command line args to set fields


- crud + list
 - by object - invoice new ...
 - or by op - new invoice ...
  - more consistent with report xxx

 - allow values to be provide like id=INV-20191111
  - if provided they are not prompted for
 - perform consitency checks
  - referenced object exist like accounts, customer, ect

- reports - generic or *specific*
 - specific
  - easy to get ID for operations on row object
  - can implement things like filtering row for display based on hidden attributes
  - can display items differently, boolean as checkbox for example or images for status
 - generic
  - use same display code
  - need position indicator for ID
  - need alignment indicator for each column
   - basically need to pass more info about the table
 - really come down to how to think about reports, are they generic or each custom

 - list
  - late
  - invoices
  - payments
  - accounts
  - customers
  - rates
  - vendors
  - P&L
  - transactions - mixed currencies
   - all
   - by account
  - balance sheet by category
  - income
   - minus expenses by category
   - by customer
   - outstanding (invoices not yet paid)
  - expense
   - by category
   - by vendor
  - general ledger
   - by category
   - all normalized to currency
  - sales tax
  - currency exchange gain and loss

- if generic
type Row {
  cells: [Cell]
}

type Cell {
  key: String # optional?
  int: Int
  str: String
  date: Date
  float: Float
  currency: Float
  bool: Boolean
}


- from web, use invoice, accounts, etc for reports with some special cases for some reports
- for console / terminal make special report for each
- graphql to trigger csv generation - provide header, object, and fields in orde

type Company {
  " Returns filepath to download. "
  classReport(class: String!, filter: Filter, header: [String], columns: [String]): String
}

Invoice {
  report(filter: Fliter, columns: [Kv]) String
}

type Kv {
  key: String
  val: String # column header if an arg to report
}

report(columns: [ {key: "one", val: "First"}, ...])
